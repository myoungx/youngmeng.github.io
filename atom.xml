<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>youngmeng</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://youngmeng.org/"/>
  <updated>2018-03-07T16:30:06.607Z</updated>
  <id>http://youngmeng.org/</id>
  
  <author>
    <name>youngmeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简易区块链（2）：比特币的发行与流通</title>
    <link href="http://youngmeng.org/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%882%EF%BC%89%EF%BC%9A%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%8F%91%E8%A1%8C%E4%B8%8E%E6%B5%81%E9%80%9A/"/>
    <id>http://youngmeng.org/简易区块链（2）：比特币的发行与流通/</id>
    <published>2018-03-07T04:41:33.000Z</published>
    <updated>2018-03-07T16:30:06.607Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲一下比特币的发行和流通机制。</p><a id="more"></a><p>在上一篇文章《<a href="http://youngmeng.org/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%881%EF%BC%89%EF%BC%9A%E8%B4%A7%E5%B8%81%E5%92%8C%E6%AF%94%E7%89%B9%E5%B8%81/">简易区块链（1）：货币和比特币</a>》中，简单介绍了下货币及比特币，相信大家对货币有了理解，同时也了解了比特币产生的缘由，认识到比特币与现有法币的不同。</p><p>不知道读者是否看了文末给出的比特币白皮书？如果没看也没关系，本篇文章将带你更详细的了解比特币的原理，比特币的技术实现也将放在后续的文章中。</p><p><br></p><h1 id="发行"><a href="#发行" class="headerlink" title="发行"></a>发行</h1><p>比特币不依赖于任何中心机构来发行，而是依靠一套去中心化的发行机制，随着时间逐步发行一定量的比特币。</p><p>比特币的底层技术是区块链，是将一个个区块连接起来形成的链。比特币系统相当于一个去中心化的大账本，其中的每个区块就相当于账本中的一页，每个区块中的交易信息是由去中心化的节点「挖矿」来完成的。</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp45q144dgj30xu07o3yz.jpg" alt="区块链示意图" width="100px"><br><br></div><p>不同于现实世界的挖矿，在比特币虚拟世界中，全球的任何一个人都能在这个分布式账本上记录交易信息，并通过竞争机制将自己记录的信息写进区块。这个过程就是「挖矿」，进行挖矿工作的人就是矿工。挖矿不需要矿工手动实际去挖，只需要购买一台专业的计算设备，下载挖矿软件，由计算设备计算特定的运行（哈希碰撞）就可以了。</p><p>比特币的挖矿，每十分钟全网矿工一起计算一道算术题，谁先算出答案，就相当于挖到了这个区块，同时矿工会获得系统新生的比特币奖励。中本聪在设计比特币时，为保证比特币不会那么快被挖完并稳定在大约 10 分钟挖出一个区块，设计挖矿难度每过 2016 个区块（约 2 周）动态调整一次，使得调整后的难度每生成一个区块的预计时间约为 10 分钟。</p><p>同时，规定每产生 21 万个区块，比特币奖励减半一次，直至比特币奖励不能再被细分（比特币的最小单位是小数点后 8 位）。由于比特币约每 10 分钟产生一个区块，21 万个区块大约是 4 年的时间。截止到目前，比特币产量已经减半两次，当前每挖出一个区块奖励 12.5 个比特币。按此计算，到 2140 年，比特币将无法再细分，至此比特币将全部发行完毕，总量约 2100 万枚。</p><p>从本质上，挖矿是将比特币的发行和结算进行了分布式，用全球化的算力竞争来取代中央发行机构。</p><p><br></p><h1 id="流通"><a href="#流通" class="headerlink" title="流通"></a>流通</h1><p>比特币的流通就是比特币交易或转账，将比特币从一个地址转到另一个地址。</p><p>转账需要在比特币钱包或比特币客户端中进行，输入转账相关的信息，比如接收方地址、转账金额、手续费金额等。和现实世界类似，常见的比特币交易有三种：</p><ul><li>一个输入两个输出。一个输出是对应给别人，另一个输出给自己，相当于找零。就好比买东西时需要支付 17 元，而你只有一张 20 元的纸币，在这次交易中，这个 20 的输入，就会产生一个 17 元的输出给卖方，一个 3 元的输出给自己（找零）。</li><li>多个输入一个输出。集合了多个零散的钱用于支付一个比较大的金额，比如将一些小额的硬币和纸币凑成一定金额用来付款。</li><li>一个输入多个输出。这种交易多用于商业实体分配中，比如公司给员工发工资。</li></ul><p>比特币交易的基本单位是未花费的一个交易输出，简称 UTXO（Unspent Transaction Output）。比特币网络中没有账户和余额，只有分散在区块链里的数以百万千万记的 UTXO。所谓的「余额」是比特币钱包里引申出的概念，钱包扫描区块链并查找到所有属于该地址的 UTXO 来计算该地址的余额。</p><p>比特币的最小单位是小数点后八位，即「一聪」。虽然 UTXO 中包含的比特币可以是一聪的任意倍，但 UTXO 是不可分割的，只能被创建和消耗。在进行比特币转账时，钱包会从该地址可用的 UTXO 中选取一个或多个来凑出大于或等于待付款的比特币量。另外还需要支付一定的手续费，手续费是所有的交易输入减去所有的交易输出。</p><p>被筛选出的这些 UTXO 称为交易输入，由交易创建的 UTXO 为交易输出。在这个过程中，交易输入的 UTXO 由所有者的签名来解锁并被消耗，交易输出创建新的 UTXO，并由接收者的比特币地址来锁定。</p><p>可以通过下面的 Api 查看对应地址的所有 UTXO：</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp45rgx1oej30nw03ajrk.jpg" alt="查询UTXO Api" width="100px"><br><br></div><p>但有一个特殊交易——每个区块的首个交易——称为 Coinbase 交易，该交易用于产生新的比特币用于作为挖矿的奖励，因此该交易没有输入。</p><p>交易被创建后，会被资金所有者（发出方）签名，并广播至比特币网络。一旦被发送到网络中的任意一个节点，交易将会被验证。如果验证有效，交易将会继续传播并返回接收信息；如果无效，交易停止传播并返回拒绝信息。交易被验证后，会被矿工打包进区块。</p><p>需要说明一下的是，交易真正有效需要打包该交易的区块之后有 6 个区块的确认，这是为了防止「双花」问题，后面再详细讨论。</p><p><br></p><table><tr><td bgcolor="#D3D3D3"> 简单总结一下：<br><br>1. 比特币是通过挖矿来发行的，每挖出一个区块，就会获得一定数量的比特币奖励，直到比特币被全部挖出。<br><br>2. 使用比特币钱包进行比特币转账时，发出方的 UTXO 会被解锁并销毁，会用接收方的地址创建新的 UTXO。交易会被广播至比特币网络，被节点验证通过后，就完成了比特币的流通。<br><br>   </td></tr></table><p><br></p><p>最后，既然了解了比特币的转账，那就留个地址尝试下吧，当做打赏了~</p><p><strong>BTC</strong>：1DXLx1RjmFhfcCjtUsZiGcFRnRz6WGj8ZN</p><p>或者扫码下方地址二维码：</p><div align="center"><br><br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fp45s531qzj30gp0gpq4b.jpg" alt="比特币地址" width="100"><br><br></div><p>如果你觉得有进步，欢迎关注区块链微信公众号：链站（ID：ChainStation）</p><div align="center"><br><br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fosv3ip8ljj30by0byaaw.jpg" alt="公众号二维码" width="100px"><br><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要讲一下比特币的发行和流通机制。&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://youngmeng.org/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://youngmeng.org/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BlockChain" scheme="http://youngmeng.org/tags/BlockChain/"/>
    
      <category term="比特币" scheme="http://youngmeng.org/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>简易区块链（1）：货币和比特币</title>
    <link href="http://youngmeng.org/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BE%EF%BC%881%EF%BC%89%EF%BC%9A%E8%B4%A7%E5%B8%81%E5%92%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <id>http://youngmeng.org/简易区块链（1）：货币和比特币/</id>
    <published>2018-02-25T09:31:02.000Z</published>
    <updated>2018-03-07T16:32:39.165Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于区块链公众号「链站」，ID：ChainStation。</p><font size="3"><strong>“</strong> 相信看到这篇文章的都是听说过或了解比特币和区块链的人，那到底什么是比特币和区块链呢？这里准备写个简易区块链系列简单介绍一下，主要是针对一些入门级别的人。文章尽可能抛开一些太专业的术语，用大家都能理解的形式讲解结。<strong>”</strong></font><a id="more"></a><p><br></p><h1 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h1><p>我们每天都在花钱，都在使用货币。那到底什么是货币呢？我们为什么能够使用它们买到真实存在的东西的呢？</p><p>我们都知道，在中国几千年的文化中，人们一直使用的是金银作为货币，更早的时候还有使用贝壳等。在这个阶段，无论是贝壳还是金银，它们都有一个共同的属性：稀缺性，并且人们能够广泛认同。所以，你给我一锭银子，我给你一块肉和一壶酒；同样我也可以拿这锭银子买一只鸡，或者留着银子放在以后使用。</p><p>到了后来，国家开始发行纸币，不同于金银的稀缺性，纸币的制作成本非常低，但人们同样可以使用纸币买到所需物品。这是因为纸币以国家信用背书，国家让人们相信这张纸（纸币）能够买到对应的商品。</p><p>再到后来，随着互联网的发展，又出现了记账货币，货币的增减只是银行账户中数字的变化。在这个过程中，只有中心化的银行机构具有记账权。银行记账是通过央行清算中心来清算并完成记账，同样有国家法律和信用背书。</p><p>从上面几个阶段知道，货币在人们交易中承担的属性：</p><ul><li><strong>交换媒介</strong>。你给我货币，我给你相应的物品；同样我也可以拿货币去换我想要的物品。</li><li><strong>记账单位</strong>。你的这只鸡到底是值一锭金子还是两锭银子，作为物品交易过程中的刻度。</li><li><strong>价值存储</strong>。早期货币（比如金银贝壳等）在被保存起来时，是将其价值存储起来，在以后的交易流通中，仍然能够购买物品。但在现代货币中，通货膨胀会削弱货币的购买力，准确来说已经不具备价值存储属性。</li></ul><p><br></p><h1 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h1><p>现在的货币由于完全是银行来发行，且银行有唯一的记账权，当银行无限增发货币时，人们手中的货币价值就会降低，导致通货膨胀，严重的情况下会引发经济危机，比如 2008 年全球经济危机。</p><p>也正是在这个时候，一个叫做中本聪的人对当前的货币体系感到不合理，于是提出了一种全新的理念：<strong>每个人都有记账权，且账本公开透明，每个人都能查看，最重要的是货币不能超发。</strong></p><p>基于这种理念，中本聪提出了「比特币」的概念，并于网络上发表了一篇名为《Bitcoin: A Peer-to-Peer Electronic Cash System》（比特币：一种点对点的电子现金系统）的论文（比特币白皮书）。论文中提出比特币是一种去中心化的电子现金系统，解决了在没有中心机构的情况下，数量恒定的资产的发行和流通问题。</p><p>2009 年 1 月 3 日中本聪打包了第一个区块，即创世区块，并获得了 50 个比特币的挖矿奖励。为了纪念比特币的诞生，中本聪将当天的泰晤士报头版标题「The Times 03/Jan/2009, Chancellor on brink of second bailout for banks」刻在了创世区块上。</p><div align="center"><br><br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fosufaap32j30va0ys421.jpg" alt="比特币地址" width="100px"><br><br></div><p>奖励数量每四年减半一次。以此计算，比特币预计在 2140 年发行完毕，总量约 2100 万枚。比特币网络中任何两个人之间都可以进行比特币转账，不会受距离及国家等因素限制。所有的转账都会被全网记录，并且公开透明，任何人都可以查看转账记录，并且无法更改。</p><p>比特币白皮书的问世也标志着比特币底层技术区块链的诞生。在本系列后面的文章中，将从区块链的角度讲解比特币原理及区块链技术。</p><p><br></p><p>如果你觉得有进步，欢迎关注区块链微信公众号：链站（ID：ChainStation）</p><div align="center"><br><br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fosv3ip8ljj30by0byaaw.jpg" alt="比特币地址" width="100px"><br><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首发于区块链公众号「链站」，ID：ChainStation。&lt;/p&gt;
&lt;font size=3&gt;&lt;strong&gt;“&lt;/strong&gt; 相信看到这篇文章的都是听说过或了解比特币和区块链的人，那到底什么是比特币和区块链呢？这里准备写个简易区块链系列简单介绍一下，主要是针对一些入门级别的人。文章尽可能抛开一些太专业的术语，用大家都能理解的形式讲解结。&lt;strong&gt;”&lt;/strong&gt;&lt;/font&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://youngmeng.org/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://youngmeng.org/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BlockChain" scheme="http://youngmeng.org/tags/BlockChain/"/>
    
      <category term="货币" scheme="http://youngmeng.org/tags/%E8%B4%A7%E5%B8%81/"/>
    
      <category term="比特币" scheme="http://youngmeng.org/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>求两个有序数组的中位数(Median of Two Sorted Arrays)</title>
    <link href="http://youngmeng.org/%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0(Median-of-Two-Sorted-Arrays)/"/>
    <id>http://youngmeng.org/求两个有序数组的中位数(Median-of-Two-Sorted-Arrays)/</id>
    <published>2017-10-27T01:07:46.000Z</published>
    <updated>2017-10-28T16:40:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 很经典的一道算法题，求两个有序数组的中位数。</p><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nums1 = [1, 3]</div><div class="line">nums2 = [2]</div><div class="line"></div><div class="line">The median is 2.0</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">nums1 = [1, 2]</div><div class="line">nums2 = [3, 4]</div><div class="line"></div><div class="line">The median is (2 + 3)/2 = 2.5</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这题如果直接采用两个指针遍历数组，对比两个指针的数值大小，逐步找到中位数的方法，时间复杂度为 <em>O(k)</em>，但如果 <em>k</em> 接近 <em>m+n</em> 的时候，就是 <em>O(m+n)</em>，不符合题目要求的复杂度 <em>O(log (m+n))</em>。</p><p>根据我们的经验，时间复杂度出现对数的情况，一般都是由于使用了中分或类似于中分的思想。朝着这个方向，可以对两个数组同时采用中分的思路，再分析得到的数与实际要求的数的关系。</p><p>题目要求的是两个数组的中位数，如果将题意拓宽一下：对于两个有序数组，求出其第 <em>k</em> 小的数。把这个问题解决了，中位数的问题就迎刃而解了。</p><p>假设 <em>nums1</em> 和 <em>nums2</em> 的元素个数都大于 <em>k/2</em> 个，比较 <em>nums1[k/2]</em> 和 <em>nums2[k/2]</em> 两个元素，有三种结果：</p><ul><li>nums1[k/2 - 1] == nums2[k/2 - 1]</li><li>nums1[k/2 - 1] &gt; nums2[k/2 - 1]</li><li>nums1[k/2 - 1] &lt; nums2[k/2 - 1]</li></ul><p>1）如果 <em>nums1[k/2 - 1] &lt; nums2[k/2 - 1]</em>，说明第 <em>k</em> 小的元素一定不在 nums1[0] ~ nums1[k/2 - 1] 里。证明如下：</p><p><strong>反证法</strong></p><p>先看实际情况，由于两个数组都是有序的，则 <em>nums1</em> 中至多有 <em>k/2-1</em> 个元素小于 <em>nums1[k/2 -1]</em>，<em>nums2</em> 中同样至多有 <em>k/2-1</em> 个元素小于 <em>nums1[k/2 -1]</em>，所以合并后的数组小于 <em>nums1[k/2 -1]</em> 的元素个数至多有 <em>k/2 - 1 + k/2 - 1 = k - 2</em> 个。</p><p>假设第 <em>k</em> 小的元素在 nums1[0] ~ nums1[k/2 - 1] 里，那么 nums1[k/2 - 1] 至少是第 <em>k+1</em> 小元素，这就与「 <em>nums1[k/2 -1]</em> 的元素个数至多有 <em>k/2 - 1 + k/2 - 1 = k - 2</em> 个」相矛盾。</p><p>2）如果  <em>nums1[k/2 - 1] &gt; nums2[k/2 - 1]</em>，同样可以证明，第 <em>k</em> 小的元素一定不在 nums2[0] ~ nums2[k/2 - 1] 里。</p><p>3）如果 <em>nums1[k/2 - 1] = nums2[k/2 - 1]</em>，那么说明 nums1[k/2 - 1] 或 nums2[k/2 - 1] 就是第 <em>k</em> 小的元素。</p><p>通过反复比较剔除掉不可能在的数组范围，逐步缩小数组区间，利用采用<strong>递归</strong>实现。递归的终止条件：</p><ul><li>当 nums1 的长度为 0，直接返回 nums2[k - 1]；</li><li>当 k = 1，返回 nums1[0] 和 nums2[0] 的较小值；</li><li>当 nums1[k/2 - 1] == nums2[k/2 - 1]，可以返回 nums1[k/2 - 1] 或nums2[k/2 - 1] ，也可以归纳到 <em>nums1[k/2 - 1] &lt; nums2[k/2 - 1]</em> 这种情况，走「 nums1 长度为 0 」的终止条件。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums1: List[int]</div><div class="line">        :type nums2: List[int]</div><div class="line">        :rtype: float</div><div class="line">        """</div><div class="line">        len1 = len(nums1)</div><div class="line">        len2 = len(nums2)</div><div class="line">        <span class="keyword">if</span> (len1 + len2) % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> (self.findKth(nums1, nums2, (len1 + len2) / <span class="number">2</span>) + self.findKth(nums1, nums2, (len1 + len2) / <span class="number">2</span> + <span class="number">1</span>)) * <span class="number">0.5</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> self.findKth(nums1, nums2, (len1 + len2) / <span class="number">2</span> + <span class="number">1</span>)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span><span class="params">(self, A, B, k)</span>:</span></div><div class="line">        lena = len(A)</div><div class="line">        lenb = len(B)</div><div class="line">        <span class="keyword">if</span> lena &gt; lenb:</div><div class="line">            <span class="keyword">return</span> self.findKth(B, A, k)</div><div class="line">        <span class="keyword">if</span> lena == <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> B[k - <span class="number">1</span>]</div><div class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> min(A[<span class="number">0</span>], B[<span class="number">0</span>])</div><div class="line">        </div><div class="line">        pa = min(k / <span class="number">2</span>, lena)</div><div class="line">        pb = k - pa</div><div class="line">        <span class="keyword">if</span> A[pa - <span class="number">1</span>] &lt;= B[pb - <span class="number">1</span>]:</div><div class="line">            <span class="keyword">return</span> self.findKth(A[pa:], B, pb)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> self.findKth(A, B[pb:], pa)</div></pre></td></tr></table></figure><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[])</span> </span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> lengthA = A.length;</div><div class="line">        <span class="keyword">int</span> lengthB = B.length;</div><div class="line">        <span class="keyword">int</span> lengthAB = lengthA + lengthB;</div><div class="line">        <span class="keyword">if</span>(lengthAB % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> (findKth(A, <span class="number">0</span>, lengthA - <span class="number">1</span>, B, <span class="number">0</span>, lengthB - <span class="number">1</span>, lengthAB / <span class="number">2</span>) </div><div class="line">                    + findKth(A, <span class="number">0</span>, lengthA - <span class="number">1</span>, B, <span class="number">0</span>, lengthB - <span class="number">1</span>, lengthAB / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> findKth(A, <span class="number">0</span>, lengthA - <span class="number">1</span>, B, <span class="number">0</span>, lengthB - <span class="number">1</span>, lengthAB / <span class="number">2</span> + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> startA, <span class="keyword">int</span> endA, <span class="keyword">int</span>[] B, <span class="keyword">int</span> startB, <span class="keyword">int</span> endB, <span class="keyword">int</span> k)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> lenA = endA - startA + <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> lenB = endB - startB + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(lenA &gt; lenB)</div><div class="line">            <span class="keyword">return</span> findKth(B, startB, endB, A, startA, endA, k);</div><div class="line">        <span class="keyword">if</span>(lenA == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> B[startB + k - <span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> A[startA] &lt; B[startB] ? A[startA] : B[startB];</div><div class="line">                </div><div class="line">        <span class="keyword">int</span> pA = k/<span class="number">2</span> &lt; lenA ? k/<span class="number">2</span> : lenA;</div><div class="line">        <span class="keyword">int</span> pB = k - pA;</div><div class="line">        <span class="keyword">if</span>(A[startA + pA - <span class="number">1</span>] &lt; B[startB + pB - <span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> findKth(A, startA + pA, endA, B, startB, endB , k - pA);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A[startA + pA - <span class="number">1</span>] &gt; B[startB + pB - <span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> findKth(A, startA, endA, B, startB + pB, endB, k - pB);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> A[startA + pA - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 很经典的一道算法题，求两个有序数组的中位数。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://youngmeng.org/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="技术" scheme="http://youngmeng.org/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="http://youngmeng.org/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://youngmeng.org/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发工具集</title>
    <link href="http://youngmeng.org/Android-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <id>http://youngmeng.org/Android-开发工具集/</id>
    <published>2017-07-31T11:10:29.000Z</published>
    <updated>2018-03-07T15:27:22.439Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一些 Android 开发过程中使用到的一些工具，用于提升 Android 开发的效率，同时也增加一些乐趣。</p><a id="more"></a><h1 id="提升构建速度"><a href="#提升构建速度" class="headerlink" title="提升构建速度"></a>提升构建速度</h1><p>Android Studio（AS）采用 Gradle 来构建 App 之后，构建速度一直被人诟病。Google 也意识到了构建速度的鸡肋，于是在 AS 2.0 中引入 Instant Run；一些大的公司也着手解决构建速度的问题，比如 Facebook 的 Buck/okbuck；同时也有一些插件用于提升构建速度。</p><p>下面简单介绍几种加快构建速度的方案，提供一个可以在项目开发过程中使用的方案。</p><h2 id="Instant-Run"><a href="#Instant-Run" class="headerlink" title="Instant Run"></a>Instant Run</h2><p>官方文档：<a href="https://developer.android.com/studio/run/index.html#instant-run" target="_blank" rel="external">https://developer.android.com/studio/run/index.html#instant-run</a>。</p><p>AS 2.0 加入，要求 Gradle 版本 2.0.0 及以上， minSDKVersion 为 15 及以上。为了获得更加性能，minSDKVersion 设置为 21 及以上（主要用于支持「冷交换」）。</p><p>Instant Run 首次构建需要花费较多时间，后续更新时无需构建新的 apk，更快地看到更改。Instant Run 提供三种方式推送更改：</p><ul><li>热交换（Hot Swap）</li><li>温和交换（Warm Swap）</li><li>冷交换（Cold Swap）</li></ul><p>三种方式的速度：热交换 &gt; 温和交换 &gt; 冷交换。</p><p>三种交换方式的使用场景：</p><table><thead><tr><th style="text-align:center">方式</th><th style="text-align:center">场景</th></tr></thead><tbody><tr><td style="text-align:center">热交换</td><td style="text-align:center">更改方法的实现；更改变量值</td></tr><tr><td style="text-align:center">温和交换</td><td style="text-align:center">资源文件（resource）的更改、移除等</td></tr><tr><td style="text-align:center">冷交换</td><td style="text-align:center">结构性的改变：更改继承关系；移除或修改静态字段、方法签名等</td></tr></tbody></table><p>Instant Run 的使用：</p><p>AS → Preferences → Build，Execution，Deployment → Instant Run。</p><div align="center"><br><br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fp4nxpmx0jj31kw113wju.jpg" alt="Instant Run 配置" width="100px"><br><br></div><h2 id="JRebel-for-Android"><a href="#JRebel-for-Android" class="headerlink" title="JRebel for Android"></a>JRebel for Android</h2><p>JRebel 号称调试神器，允许应用程序代码更新之后不用重新部署或重启直接能看到更改。官方网站：<a href="https://zeroturnaround.com/" target="_blank" rel="external">https://zeroturnaround.com/</a>。</p><p>在 AS 上提供了一个 JRebel 插件。通过 Preference -&gt; Plugins -&gt; Browse Repositories 搜索JRebel ，安装重启即可。重启后即可在工具栏看到插件相关按钮：</p><div align="center"><br><br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fp4nyxsgynj302r010jr6.jpg" alt="JRebel功能按钮"><br><br></div><p><strong>第一次安装的时候使用第一个，之后代码变更后查看变更使用第三个，调试使用第二个。</strong></p><p>官方号称速度比 Instant Run 快至少 8 倍以上。而且稳定，更新频率极快。之前一直收费，但有 21 天的试用期。现在出了个企业版和个人免费版，企业版可以适用 14 天，个人免费版就能满足日常使用。</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp4nzs1wnlj31kw0hj0wg.jpg" alt="JRebel与instant run速度对比" width="100px"><br><br></div><h2 id="Freeline"><a href="#Freeline" class="headerlink" title="Freeline"></a>Freeline</h2><p>Freeline 号称是 Android 平台上的秒级编译方案，蚂蚁聚宝 Android 团队开发。官方网站：<a href="https://www.freelinebuild.com/" target="_blank" rel="external">https://www.freelinebuild.com/</a>。</p><p>首次编译时间较长，后续改动编译充分利用缓存文件，几秒内就能部署新的改动。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1  命令行接入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//配置 project-level 的 build.gradle，加入 freeline-gradle 的依赖：</span></div><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath <span class="string">'com.antfortune.freeline:gradle:x.x.x'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">//主 module 的 build.gradle 中，应用 freeline 插件的依赖：</span></div><div class="line">apply plugin: <span class="string">'com.antfortune.freeline'</span></div><div class="line"> </div><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2  插件接入</p><p>在 AS 中搜索插件 「freeline」，安装重启。</p><p>第一次使用时会自动检测是否安装了 Freeline，如果没有安装会自动提示，确定后会进行安装并自动修改配置文件；如果已经安装了，就可以直接运行。</p><div align="center"><br><br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fp4o13mrk5j30tk01ogn0.jpg" alt="freeline插件图标" width="100px"><br><br></div><p>关于 release 包代码侵入性的问题，Freeline 官方说法：</p><blockquote><p>Freeline 对 release 打包几乎没有影响。Freeline 在 release 打包的时候自动添加的是 no-op 的 runtime 依赖，对 FreelineCore.init(this); 函数是一个空实现。如果你开启了 Application 代理的话，更是基本上毫无影响，请放心使用。</p><p>如果你还是实在放心不下的话，可以在打 release 包的时候，把 Freeline 相关的内容注释掉，然后 clean and build。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Instant-Run-1"><a href="#Instant-Run-1" class="headerlink" title="Instant Run"></a>Instant Run</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>AS 自带，随着 AS 升级，Google 会进行持续迭代优化</li><li>零配置，不需要额外的其他任何安装、配置流程，直接使用</li><li>基本无侵入性</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>可修改的地方有局限性</li><li>覆盖的 case 较少，经常出现其他关联问题</li><li>修改结构性代码的话，会重启应用，对层级较深的页面，使用起来不方便</li><li>增量代码不支持 debug</li><li>不支持 Kotlin</li></ul><h3 id="JRebel-for-Android-1"><a href="#JRebel-for-Android-1" class="headerlink" title="JRebel for Android"></a>JRebel for Android</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>零配置，只需安装 AS 插件</li><li><strong>使用起来非常方便</strong></li><li>支持debug</li><li>相比 Instant Run 支持范围更广（<a href="https://zeroturnaround.com/rebellabs/jrebel-for-android-and-instant-run-compared/" target="_blank" rel="external">https://zeroturnaround.com/rebellabs/jrebel-for-android-and-instant-run-compared/</a>）</li></ul><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp4o2w22nij310012642z.jpg" alt="JRebel和Instant Run比较" width="100px"><br><br></div><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>个人免费功能有限（但要求不高够用），收费版价格较高</li><li>首次编译、安装速度比较慢</li><li>crash 后需要重新全量编译</li></ul><h3 id="Freeline-1"><a href="#Freeline-1" class="headerlink" title="Freeline"></a>Freeline</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>支持一堆东西：so 动态替换、DataBinding、Retrolambda 与注解（来源官方文档）</li><li>速度极快，秒级方案；大多数情况下的增量编译都可在 10s 内完成</li><li>crash 后，仍然可以通过增量编译来修复</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>初次编译构建时间较久</li><li>代码有侵入性（比较低，官方说几乎不影响）</li><li>不支持 Kotlin</li></ul><h1 id="查看包名及-Activity"><a href="#查看包名及-Activity" class="headerlink" title="查看包名及 Activity"></a>查看包名及 Activity</h1><h4 id="App-名称"><a href="#App-名称" class="headerlink" title="App 名称"></a>App 名称</h4><p>当前 Activity</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>显示最前台页面所在的应用的包名和 Activity。</p><div align="center"><br><br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fp4o3rdi57j30jx0dftdh.jpg" width="100px"><br><br></div><h4 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h4><ul><li><a href="https://play.google.com/store/apps/details?id=com.willme.topactivity" target="_blank" rel="external">当前Activity - Google Play</a></li><li><a href="https://github.com/109021017/android-TopActivity" target="_blank" rel="external">android-TopActivity - GitHub</a></li></ul><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ol><li>如要使用，某些手机需要在 <em>辅助功能 - 无障碍</em> 设置中，开启「当前Activity」的开关。</li><li>adb 相关命令：<ul><li>查看当前 Activity：adb shell “dumpsys window w | grep name=”</li><li>查看当前栈顶的 Activity：adb shell dumpsys activity | grep<br>“mFocusedActivity”</li><li>查看当前栈顶的 Activity 的 Fragment：adb shell dumpsys activity your.package.name</li></ul></li></ol><h1 id="电脑控制手机"><a href="#电脑控制手机" class="headerlink" title="电脑控制手机"></a>电脑控制手机</h1><h4 id="插件名称"><a href="#插件名称" class="headerlink" title="插件名称"></a>插件名称</h4><p>vysor</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>在电脑上控制手机，轻松截屏、录屏，方便快捷。</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp4o4tzciqj30ms196k0j.jpg" alt="vysor界面" width="100px"><br><br></div><h4 id="下载链接-1"><a href="#下载链接-1" class="headerlink" title="下载链接"></a>下载链接</h4><p><a href="https://chrome.google.com/webstore/search/vysor?hl=zh-CN" target="_blank" rel="external">chrome 插件</a></p><h4 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h4><p>录屏需要购买 Pro 版本。</p><h1 id="获取设备信息"><a href="#获取设备信息" class="headerlink" title="获取设备信息"></a>获取设备信息</h1><h4 id="App-名称-1"><a href="#App-名称-1" class="headerlink" title="App 名称"></a>App 名称</h4><p>开发助手</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>方便查看和设备相关的信息及进行相关设置。</p><div align="center"><br><br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fp4o5mvus5j30k00zkk41.jpg" alt="开发助手界面" width="100px"><br><br></div><h4 id="下载链接-2"><a href="#下载链接-2" class="headerlink" title="下载链接"></a>下载链接</h4><p><a href="https://play.google.com/store/apps/details?id=cn.trinea.android.developertools" target="_blank" rel="external">开发助手 - Google play</a></p><h4 id="tips-2"><a href="#tips-2" class="headerlink" title="tips"></a>tips</h4><p>开发助手由 Trinea 开发，其 GitHub 地址为：<a href="https://github.com/Trinea" target="_blank" rel="external">https://github.com/Trinea</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一些 Android 开发过程中使用到的一些工具，用于提升 Android 开发的效率，同时也增加一些乐趣。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://youngmeng.org/categories/Android/"/>
    
    
      <category term="技术" scheme="http://youngmeng.org/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://youngmeng.org/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android手势密码探索</title>
    <link href="http://youngmeng.org/Android%E6%89%8B%E5%8A%BF%E5%AF%86%E7%A0%81%E6%8E%A2%E7%B4%A2/"/>
    <id>http://youngmeng.org/Android手势密码探索/</id>
    <published>2017-03-16T13:35:35.000Z</published>
    <updated>2018-03-07T15:17:57.915Z</updated>
    
    <content type="html"><![CDATA[<p>Android 智能手机在全球市场有着极高的市场占有率，越来越受到广大消费者的青睐。但 Android 作为开源操作系统，且很容易可以获得系统 root 权限，Android 系统的安全问题也是用户和开发者最关心的问题之一。<br><a id="more"></a></p><p>Android 智能手机在全球市场有着极高的市场占有率，越来越受到广大消费者的青睐。但 Android 作为开源操作系统，且很容易可以获得系统 root 权限，Android 系统的安全问题也是用户和开发者最关心的问题之一。</p><p>手势密码作为手机上方便的一种安全保护措施，受到了众多 APP 开发者的青睐，市场上一些金融类 APP 基本都配有手势密码，如下图即为手势绘制过程的一个状态。</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp4nvxc58oj309y0dq74l.jpg" alt="手势密码" width="100px"><br><br></div><p>目前大多数 Android 手机都具有手势锁屏功能，Android 系统自身是带了手势密码功能的，不同的 ROM 厂商做了不同的定制。本文通过Android自身的源码简单介绍手势密码的原理。</p><h1 id="Android手势相关类"><a href="#Android手势相关类" class="headerlink" title="Android手势相关类"></a>Android手势相关类</h1><p>回忆或者尝试一下用手势解锁 Android 手机的过程：首先用户通过点击九宫格的点连接出一条路径，当手指抬起时，会判断此次连接的点路径是否和设置的相匹配。</p><p>在这个过程中，涉及到两个方面（不考虑设置手势时的存储）：</p><ul><li>手势的绘制</li><li>手势的验证/匹配</li></ul><p>针对这两个过程，通过 AOSP 查找源码，我们可以发现两个相关类：</p><ul><li>LockPatternView.java：View类，九宫格手势图形显示的类。</li><li>LockPatternUtils.java：手势转换、匹配工具类。</li></ul><p>本篇文章通过分析这两个类中重要的部分来说明手势表示和绘制的原理。</p><h2 id="LockPatternView"><a href="#LockPatternView" class="headerlink" title="LockPatternView"></a>LockPatternView</h2><p>该类是 View 的子类，其中定义了整个手势绘制区相关的 View，比如九宫格的点、绘制的路径、View 的状态模式、以及手势监听等。类中覆写了 View 父类的 onDraw 方法，点的选中状态、绘制线条都是实时绘制的。</p><p>九宫格中的每个「宫」作为静态内部类定义为 <em>Cell</em>，每个 <em>Cell</em> 包括两个坐标，即行（row）和列（column），row 和 column 的范围均在 [0, 3) 内。这样定义的好处，一是利用矩阵的思想来表示九宫格，二是可以把「row * 3 + column」作为 Cell 的值，用 0~8 共 9 个数字来表示九宫格。比如，绘制的路径是 「L」 型，就可以用「03678」来表示这个路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> <span class="keyword">int</span> row;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> column;</div><div class="line"></div><div class="line">        <span class="comment">// keep # objects limited to 9</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cell[][] sCells = createCells();</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Cell[][] createCells() &#123;</div><div class="line">            Cell[][] res = <span class="keyword">new</span> Cell[<span class="number">3</span>][<span class="number">3</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</div><div class="line">                    res[i][j] = <span class="keyword">new</span> Cell(i, j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * <span class="doctag">@param</span> row The row of the cell.</div><div class="line">         * <span class="doctag">@param</span> column The column of the cell.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Cell</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</div><div class="line">            checkRange(row, column);</div><div class="line">            <span class="keyword">this</span>.row = row;</div><div class="line">            <span class="keyword">this</span>.column = column;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRow</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> row;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumn</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> column;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cell <span class="title">of</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</div><div class="line">            checkRange(row, column);</div><div class="line">            <span class="keyword">return</span> sCells[row][column];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkRange</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"row must be in range 0-2"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (column &lt; <span class="number">0</span> || column &gt; <span class="number">2</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"column must be in range 0-2"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"(row="</span> + row + <span class="string">",clmn="</span> + column + <span class="string">")"</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>手势绘制过程中，一般有三种状态：绘制正确、正在绘制、绘制错误（实际开发可以设置为四种，第四种即锁定状态）。</p><p>手势九宫格用「DisplayMode」表示三种显示模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DisplayMode &#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The pattern drawn is correct (i.e draw it in a friendly color)</div><div class="line">         */</div><div class="line">        Correct,</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Animate the pattern (for demo, and help).</div><div class="line">         */</div><div class="line">        Animate,</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The pattern is wrong (i.e draw a foreboding color)</div><div class="line">         */</div><div class="line">        Wrong</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>通过三种模式，可以更改绘制手势过程中及结束后手势状态。比如，更改颜色以表示状态：让绘制的过程中，选中的 Cell 和线条用蓝色表示，绘制错误时用红色表示，绘制正确时用绿色表示。</p><p>手势绘制过程中通过接口OnPatternListener中的4个监听函数来监听手势开始、结束、清除、添加等操作。接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnPatternListener</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * A new pattern has begun.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onPatternStart</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The pattern was cleared.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onPatternCleared</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * The user extended the pattern currently being drawn by one cell.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> pattern The pattern with newly added cell.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onPatternCellAdded</span><span class="params">(List&lt;Cell&gt; pattern)</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * A pattern was detected from the user.</div><div class="line">         *</div><div class="line">         * <span class="doctag">@param</span> pattern The pattern.</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onPatternDetected</span><span class="params">(List&lt;Cell&gt; pattern)</span></span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>从方法名和注释就可以看出每个方法的含义，在此不再赘述。</p><p>接下来看下，手势在绘制手势的过程中，View是如何判断手指当前位置是否选中某个 <em>Cell</em> ，以及是否应该把该 <em>Cell</em> 连接入手势。这里需要了解几个函数：</p><ul><li><p>getRowHit ( float  y )</p><p>用来确定手指当前坐标 (x, y) 位于九宫格的第几<strong>排</strong>。</p></li><li><p>getColumnHit (float  x )</p><p>用来确定手指当前坐标 (x, y) 位于九宫格的第几<strong>列</strong>。</p></li><li><p>checkForNewHit (float x, float y)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Cell <span class="title">checkForNewHit</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rowHit = getRowHit(y);</div><div class="line">        <span class="keyword">if</span> (rowHit &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> columnHit = getColumnHit(x);</div><div class="line">        <span class="keyword">if</span> (columnHit &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mPatternDrawLookup[rowHit][columnHit]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> Cell.of(rowHit, columnHit);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>函数代码很好理解，mPatternDrawLookup 是个全局变量，同样采用矩阵的形式，用于标记九宫格中哪个 Cell 被连接。从 checkForNewHit 中可以看出，已经被连接的 Cell，是不会再被选中的，这也是目前手势密码普遍的做法。如果你需要实现“每个点可以被连接多次”的需求，这部分就需要改动了。</p></li><li><p>detectAndAddHit (float x, float y)</p><p>用来检测并判断手指当前坐标 (x, y) 是否需要添加添加进当前手势中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Cell <span class="title">detectAndAddHit</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Cell cell = checkForNewHit(x, y);</div><div class="line">        <span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// check for gaps in existing pattern</span></div><div class="line">            Cell fillInGapCell = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">final</span> ArrayList&lt;Cell&gt; pattern = mPattern;</div><div class="line">            <span class="keyword">if</span> (!pattern.isEmpty()) &#123;</div><div class="line">                <span class="keyword">final</span> Cell lastCell = pattern.get(pattern.size() - <span class="number">1</span>);</div><div class="line">                <span class="keyword">int</span> dRow = cell.row - lastCell.row;</div><div class="line">                <span class="keyword">int</span> dColumn = cell.column - lastCell.column;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> fillInRow = lastCell.row;</div><div class="line">                <span class="keyword">int</span> fillInColumn = lastCell.column;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (Math.abs(dRow) == <span class="number">2</span> &amp;&amp; Math.abs(dColumn) != <span class="number">1</span>) &#123;</div><div class="line">                    fillInRow = lastCell.row + ((dRow &gt; <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (Math.abs(dColumn) == <span class="number">2</span> &amp;&amp; Math.abs(dRow) != <span class="number">1</span>) &#123;</div><div class="line">                    fillInColumn = lastCell.column + ((dColumn &gt; <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                fillInGapCell = Cell.of(fillInRow, fillInColumn);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (fillInGapCell != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                    !mPatternDrawLookup[fillInGapCell.row][fillInGapCell.column]) &#123;</div><div class="line">                addCellToPattern(fillInGapCell);</div><div class="line">            &#125;</div><div class="line">            addCellToPattern(cell);</div><div class="line">            <span class="keyword">if</span> (mEnableHapticFeedback) &#123;</div><div class="line">                performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY,</div><div class="line">                        HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING</div><div class="line">                        | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> cell;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>首先通过 checkForNewHit 获得当前位置的的 Cell，计算当前Cell 与手势中最后一个 Cell 的行列差值。看其中一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Math.abs(dRow) == <span class="number">2</span> &amp;&amp; Math.abs(dColumn) != <span class="number">1</span>) &#123;</div><div class="line">    fillInRow = lastCell.row + ((dRow &gt; <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (Math.abs(dColumn) == <span class="number">2</span> &amp;&amp; Math.abs(dRow) != <span class="number">1</span>) &#123;</div><div class="line">    fillInColumn = lastCell.column + ((dColumn &gt; <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fillInGapCell = Cell.of(fillInRow, fillInColumn);</div></pre></td></tr></table></figure><p>判断条件是：当前 Cell 与手势中最后一个 Cell 的<strong>行</strong>或者<strong>列</strong>的绝对差值为 2，且其<strong>列</strong>或<strong>行</strong>的绝对差值不为1，即两个 Cell 不相邻（包括水平、竖直、45°方向的相邻），获得当前 Cell 与手势中最后一个 Cell 之间的 Cell，如果该 Cell 没有被添加进去过，则添加进手势。</p><p>意思就是说，绘制的手势不会跨过没有添加的点。</p></li></ul><hr><p>前面说到，绘制过程中选中的点和未选中的点是通过覆写 View 的 onDraw 方法实时绘制的。onDraw代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ArrayList&lt;Cell&gt; pattern = mPattern;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = pattern.size();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[][] drawLookup = mPatternDrawLookup;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mPatternDisplayMode == DisplayMode.Animate) &#123;</div><div class="line"></div><div class="line">            <span class="comment">// figure out which circles to draw</span></div><div class="line"></div><div class="line">            <span class="comment">// + 1 so we pause on complete pattern</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> oneCycle = (count + <span class="number">1</span>) * MILLIS_PER_CIRCLE_ANIMATING;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> spotInCycle = (<span class="keyword">int</span>) (SystemClock.elapsedRealtime() -</div><div class="line">                    mAnimatingPeriodStart) % oneCycle;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numCircles = spotInCycle / MILLIS_PER_CIRCLE_ANIMATING;</div><div class="line"></div><div class="line">            clearPatternDrawLookup();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCircles; i++) &#123;</div><div class="line">                <span class="keyword">final</span> Cell cell = pattern.get(i);</div><div class="line">                drawLookup[cell.getRow()][cell.getColumn()] = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// figure out in progress portion of ghosting line</span></div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needToUpdateInProgressPoint = numCircles &gt; <span class="number">0</span></div><div class="line">                    &amp;&amp; numCircles &lt; count;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (needToUpdateInProgressPoint) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> percentageOfNextCircle =</div><div class="line">                        ((<span class="keyword">float</span>) (spotInCycle % MILLIS_PER_CIRCLE_ANIMATING)) /</div><div class="line">                                MILLIS_PER_CIRCLE_ANIMATING;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> Cell currentCell = pattern.get(numCircles - <span class="number">1</span>);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> centerX = getCenterXForColumn(currentCell.column);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> centerY = getCenterYForRow(currentCell.row);</div><div class="line"></div><div class="line">                <span class="keyword">final</span> Cell nextCell = pattern.get(numCircles);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> dx = percentageOfNextCircle *</div><div class="line">                        (getCenterXForColumn(nextCell.column) - centerX);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> dy = percentageOfNextCircle *</div><div class="line">                        (getCenterYForRow(nextCell.row) - centerY);</div><div class="line">                mInProgressX = centerX + dx;</div><div class="line">                mInProgressY = centerY + dy;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> Infinite loop here...</span></div><div class="line">            invalidate();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Path currentPath = mCurrentPath;</div><div class="line">        currentPath.rewind();</div><div class="line"></div><div class="line">        <span class="comment">// draw the circles</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            <span class="keyword">float</span> centerY = getCenterYForRow(i);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</div><div class="line">                CellState cellState = mCellStates[i][j];</div><div class="line">                <span class="keyword">float</span> centerX = getCenterXForColumn(j);</div><div class="line">                <span class="keyword">float</span> translationY = cellState.translationY;</div><div class="line">                <span class="keyword">if</span> (isHardwareAccelerated() &amp;&amp; cellState.hwAnimating) &#123;</div><div class="line">                    DisplayListCanvas displayListCanvas = (DisplayListCanvas) canvas;</div><div class="line">                    displayListCanvas.drawCircle(cellState.hwCenterX, cellState.hwCenterY,</div><div class="line">                            cellState.hwRadius, cellState.hwPaint);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    drawCircle(canvas, (<span class="keyword">int</span>) centerX, (<span class="keyword">int</span>) centerY + translationY,</div><div class="line">                            cellState.radius, drawLookup[i][j], cellState.alpha);</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> the path should be created and cached every time we hit-detect a cell</span></div><div class="line">        <span class="comment">// only the last segment of the path should be computed here</span></div><div class="line">        <span class="comment">// draw the path of the pattern (unless we are in stealth mode)</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> drawPath = !mInStealthMode;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (drawPath) &#123;</div><div class="line">            mPathPaint.setColor(getCurrentColor(<span class="keyword">true</span> <span class="comment">/* partOfPattern */</span>));</div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> anyCircles = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">float</span> lastX = <span class="number">0f</span>;</div><div class="line">            <span class="keyword">float</span> lastY = <span class="number">0f</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">                Cell cell = pattern.get(i);</div><div class="line"></div><div class="line">                <span class="comment">// only draw the part of the pattern stored in</span></div><div class="line">                <span class="comment">// the lookup table (this is only different in the case</span></div><div class="line">                <span class="comment">// of animation).</span></div><div class="line">                <span class="keyword">if</span> (!drawLookup[cell.row][cell.column]) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                anyCircles = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                <span class="keyword">float</span> centerX = getCenterXForColumn(cell.column);</div><div class="line">                <span class="keyword">float</span> centerY = getCenterYForRow(cell.row);</div><div class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</div><div class="line">                    CellState state = mCellStates[cell.row][cell.column];</div><div class="line">                    currentPath.rewind();</div><div class="line">                    currentPath.moveTo(lastX, lastY);</div><div class="line">                    <span class="keyword">if</span> (state.lineEndX != Float.MIN_VALUE &amp;&amp; state.lineEndY != Float.MIN_VALUE) &#123;</div><div class="line">                        currentPath.lineTo(state.lineEndX, state.lineEndY);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        currentPath.lineTo(centerX, centerY);</div><div class="line">                    &#125;</div><div class="line">                    canvas.drawPath(currentPath, mPathPaint);</div><div class="line">                &#125;</div><div class="line">                lastX = centerX;</div><div class="line">                lastY = centerY;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// draw last in progress section</span></div><div class="line">            <span class="keyword">if</span> ((mPatternInProgress || mPatternDisplayMode == DisplayMode.Animate)</div><div class="line">                    &amp;&amp; anyCircles) &#123;</div><div class="line">                currentPath.rewind();</div><div class="line">                currentPath.moveTo(lastX, lastY);</div><div class="line">                currentPath.lineTo(mInProgressX, mInProgressY);</div><div class="line"></div><div class="line">                mPathPaint.setAlpha((<span class="keyword">int</span>) (calculateLastSegmentAlpha(</div><div class="line">                        mInProgressX, mInProgressY, lastX, lastY) * <span class="number">255f</span>));</div><div class="line">                canvas.drawPath(currentPath, mPathPaint);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这部分代码比较长，这里就不细细分析了，主要流程就是：</p><ol><li><p>判断当前显示模式是否是正在绘制。如果是，保存连接的点的状态，计算手指当前所在的点坐标；如果不是，进入第2步。</p></li><li><p>根据1中保存的状态，绘制选中的点，已更改选中的点的样式。</p><p>选中的点和未选中的点的状态都是在这部分实时完成的，通过遍历9个点，根据1中保存的状态改变画笔属性绘制不同的样式。</p></li><li><p>绘制连接线（path）。主要是获得路径，然后drawPath。</p></li></ol><p>最后就是onTouchEvent处理手指ACTION事件，包括ACTION_DOWN、ACTION_UP、ACTION_MOVE、ACTION_CANCEL事件。每种事件，判断手势绘制是否结束、改变显示模式、刷新View、回调方法。</p><h2 id="LockPatternUtils"><a href="#LockPatternUtils" class="headerlink" title="LockPatternUtils"></a>LockPatternUtils</h2><p>LockPatternUtils是处理手势的工具类，主要看下两个方法patternToString、patternToHash两个方法。</p><ul><li>patternToString</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Serialize a pattern.</div><div class="line">     * <span class="doctag">@param</span> pattern The pattern.</div><div class="line">     * <span class="doctag">@return</span> The pattern in string form.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">patternToString</span><span class="params">(List&lt;LockPatternView.Cell&gt; pattern)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (pattern == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> patternSize = pattern.size();</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] res = <span class="keyword">new</span> <span class="keyword">byte</span>[patternSize];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; patternSize; i++) &#123;</div><div class="line">            LockPatternView.Cell cell = pattern.get(i);</div><div class="line">            res[i] = (<span class="keyword">byte</span>) (cell.getRow() * <span class="number">3</span> + cell.getColumn());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>从方法定义可以看到，将手势用0~8数字，转换成byte数组来表示。</p><ul><li>patternToHash</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">     * Generate an SHA-1 hash for the pattern. Not the most secure, but it is</div><div class="line">     * at least a second level of protection. First level is that the file</div><div class="line">     * is in a location only readable by the system process.</div><div class="line">     * @param pattern the gesture pattern.</div><div class="line">     * @return the hash of the pattern in a byte array.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] patternToHash(List&lt;LockPatternView.Cell&gt; pattern) &#123;</div><div class="line">        <span class="keyword">if</span> (pattern == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> patternSize = pattern.size();</div><div class="line">        <span class="keyword">byte</span>[] res = <span class="keyword">new</span> <span class="keyword">byte</span>[patternSize];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; patternSize; i++) &#123;</div><div class="line">            LockPatternView.Cell cell = pattern.get(i);</div><div class="line">            res[i] = (<span class="keyword">byte</span>) (cell.getRow() * <span class="number">3</span> + cell.getColumn());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA-1"</span>);</div><div class="line">            <span class="keyword">byte</span>[] hash = md.digest(res);</div><div class="line">            <span class="keyword">return</span> hash;</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException nsa) &#123;</div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>patternToHash的作用是，在patternToString的基础上，采用「SHA-1」算法对byte数组进行hash散列。</p><p>值得一提的是，SHA-1虽然不可逆，但算法并不安全。如果采用暴力破解的方式，自己写个程序很快就能撞对。</p><p>也许Android的开发者也明白，Android作为开源系统，无法做到真正意义上的绝对安全，除了每个人都能获得源码外，获得系统root权限就能拿到系统所有数据，因此并没有花较大的力气来处理手势的安全问题。当然，这也是作者的猜想。</p><p>实际开发中，需要根据APP及手势需求的加密等级，对手势信息进行不同程度的加密。如果需要存储到本地，还涉及到数据的本地存储安全。</p><hr><p>通过上面的简单介绍，相信大家大致了解了手势密码的原理，上面分析的内容主要是用户可以修改的，即如果你需要自定义不同的手势样式，可以更改上面分析的对应部分。</p><p>我个人基于Android自己的LockPatternView进行了简单的修改，绘制的样式如文章开始的图所示，修改的地方如要是drawCircle、图层、画笔。相关代码可到<a href="https://github.com/youngmeng/LockPatternView" target="_blank" rel="external">youngmeng/LockPatternView</a>查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 智能手机在全球市场有着极高的市场占有率，越来越受到广大消费者的青睐。但 Android 作为开源操作系统，且很容易可以获得系统 root 权限，Android 系统的安全问题也是用户和开发者最关心的问题之一。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://youngmeng.org/categories/Android/"/>
    
    
      <category term="技术" scheme="http://youngmeng.org/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="安全" scheme="http://youngmeng.org/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>玩转Android drawable图片适配</title>
    <link href="http://youngmeng.org/%E7%8E%A9%E8%BD%ACAndroid-drawable%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D/"/>
    <id>http://youngmeng.org/玩转Android-drawable图片适配/</id>
    <published>2016-12-26T15:43:34.000Z</published>
    <updated>2018-03-07T15:16:18.719Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Android机型众多，屏幕尺寸、分辨率各有不同。对于Android开发人员来说，如何提高APP中图片对各种机型的适配是基本技能之一。借着项目中遇到的图片适配问题，在总结项目时，就想着顺带把这部分好好捋一捋，作为一个记录，也为不是很清楚这部分的人提供一个参考。<br><a id="more"></a></p><p>众所周知，Android机型众多，屏幕尺寸、分辨率各有不同。对于Android开发人员来说，如何提高APP中图片对各种机型的适配是基本技能之一。借着项目中遇到的图片适配问题，在总结项目时，就想着顺带把这部分好好捋一捋，作为一个记录，也为不是很清楚这部分的人提供一个参考。</p><h1 id="先说mipmap"><a href="#先说mipmap" class="headerlink" title="先说mipmap"></a>先说mipmap</h1><p>采用Android Studio开发Android APP，在项目的res目录下，会多出几个以mipmap开头的文件夹。</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp4nmzdinuj308q05it8x.jpg" alt="mipmap文件夹" width="100px"><br><br></div><p>根据Android官方的描述，mipmap仅仅用于存放APP启动图标，可由Image Asset Studio生成。Image Asset Studio会生成mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi五种尺寸的图标。图标最好不要随意定义尺寸，分辨率过低会模糊，过高徒增APK包大小。各种密度下的图标建议尺寸为</p><table><thead><tr><th style="text-align:center">密度</th><th style="text-align:center">建议尺寸</th></tr></thead><tbody><tr><td style="text-align:center">mdpi</td><td style="text-align:center">48*48</td></tr><tr><td style="text-align:center">hdpi</td><td style="text-align:center">72*72</td></tr><tr><td style="text-align:center">xhdpi</td><td style="text-align:center">96*96</td></tr><tr><td style="text-align:center">xxhdpi</td><td style="text-align:center">144*144</td></tr><tr><td style="text-align:center">xxxhdpi</td><td style="text-align:center">192*192</td></tr></tbody></table><p>如果要上传到Google Play，还需要一张512*512的图片用于Google Play Store。</p><h1 id="再说drawable图片适配"><a href="#再说drawable图片适配" class="headerlink" title="再说drawable图片适配"></a>再说drawable图片适配</h1><p>Android系统可以在具有不同屏幕尺寸和密度的设备上运行，并将每个应用的用户界面调整为适应其显示的屏幕，会进行缩放和大小调整。为了最大程序优化更多设备上的用户体验，开发者需要针对不同的屏幕尺寸和密度优化应用。对于Android智能手机来说，屏幕大小、分辨率、密度均不尽相同，那么图片适配就成了Android中优化应用必不可少的环节之一。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li><p>dpi</p><p>每英寸点数，全称dots per inch。用来表示屏幕密度，即屏幕物理区域中的像素量。高密度屏幕比低密度屏幕在给定物理区域的像素要多。</p></li><li><p>dp</p><p>即dip，全称device independent pixel。设备独立像素，是一种虚拟像素单位，用于以密度无关方式表示布局维度或位置，以确保在不同密度的屏幕上正常显示UI。在160dpi的设备上，1dp=1px。</p></li><li><p>density</p><p>设备的逻辑密度，是dip的缩放因子。以160dpi的屏幕为基线，density=dpi/160。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; getResources().getDisplayMetrics().density</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote></li><li><p>sp</p><p>缩放独立像素，全称scale independent pixel。类似于dp，一般用于设置字体大小，可以根据用户设置的字体大小偏好来缩放。</p></li></ul><h2 id="六种通用密度"><a href="#六种通用密度" class="headerlink" title="六种通用密度"></a>六种通用密度</h2><p>Android系统为了简化开发者为多种屏幕设计用户界面的方式，Android将实际屏幕尺寸和范围作了通用规定，称作“根据可用屏幕宽度管理屏幕尺寸的新技术”。六种通用密度为</p><table><thead><tr><th style="text-align:center">密度</th><th style="text-align:center">dpi范围</th></tr></thead><tbody><tr><td style="text-align:center">ldpi（低）</td><td style="text-align:center">~120dpi</td></tr><tr><td style="text-align:center">mdpi（中）</td><td style="text-align:center">~160dpi</td></tr><tr><td style="text-align:center">hdpi（高）</td><td style="text-align:center">~240dpi</td></tr><tr><td style="text-align:center">xhdpi（超高）</td><td style="text-align:center">~320dpi</td></tr><tr><td style="text-align:center">xxhdpi（超超高）</td><td style="text-align:center">~480dpi</td></tr><tr><td style="text-align:center">xxxhdpi（超超超高）</td><td style="text-align:center">~640dpi</td></tr></tbody></table><p>通用密度是以mdpi（中）为基线配置的，此基线基于第一代Android设备（T-Mobile G1）的屏幕配置。</p><h2 id="Android系统适配原则"><a href="#Android系统适配原则" class="headerlink" title="Android系统适配原则"></a>Android系统适配原则</h2><p>Android为了更好地优化应用在不同屏幕密度下的用户体验，在项目的res目录下可以创建drawab-[density]（density为6种通用密度名）目录，开发者在进行APP开发时，针对不同的屏幕密度，将图片放置于对应的drawable-[density]目录，Android系统会依据特定的原则来查找各drawable目录下的图片。查找流程为：</p><ol><li>先查找和屏幕密度最匹配的文件夹。如当前设备屏幕密度dpi为160，则会优先查找drawable-mdpi目录；如果设备屏幕密度dpi为420，则会优先查找drawable-xxhdpi目录。</li><li>如果在最匹配的目录没有找到对应图片，就会向更高密度的目录查找，直到没有更高密度的目录。例如，在最匹配的目录drawable-mdpi中没有查找到，就会查找drawable-hdpi目录，如果还没有查找到，就会查找drawable-xhdpi目录，直到没有更高密度的drawable-[density]目录。</li><li>如果一直往高密度目录均没有查找，Android就会查找drawable-nodpi目录。drawable-nodpi目录中的资源适用于所有密度的设备，不管当前屏幕的密度如何，系统都不会缩放此目录中的资源。因此，对于永远不希望系统缩放的资源，最简单的方法就是放在此目录中；同时，放在该目录中的资源最好不要再放到其他drawable目录下了，避免得到非预期的效果。</li><li>如果在drawable-nodpi目录也没有查找到，系统就会向比最匹配目录密度低的目录依次查找，直到没有更低密度的目录。例如，最匹配目录是xxhdpi，更高密度的目录和nodpi目录查找不到后，就会依次查找drawable-xhdp、drawable-hdpi、drawable-mdpi、drawable-ldpi。</li></ol><p>举个例子，假如当前设备的dpi是320，系统会优先去drawable-xhdpi目录查找，如果找不到，会依次查找xxhdpi → xxxhdpi → hdpi → mdpi → ldpi。对于不存在的drawable-[density]目录直接跳过，中间任一目录查找到资源，则停止本次查找。</p><p>总结一下图片查找过程：优先匹配最适合的图片→查找密度高的目录（升序）→查找密度低的目录（降序）。</p><p>资源适配流程简单归纳如下</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp4no4v8aaj30ux13j77w.jpg" alt="Android图片查找流程" width="100px"><br><br></div><p>关于Android适配更详细的介绍可以参见<a href="https://developer.android.com/guide/topics/resources/providing-resources.html#BestMatch" target="_blank" rel="external">Android 如何查找最佳匹配资源</a>，当然你可能需要搭个梯子（不过，Google已经发布了针对中国的开发者网站，对应的Android中国开发者网站为：<a href="https://developer.android.google.cn" target="_blank" rel="external">developer.android.google.cn</a>，可以免梯子）。</p><h2 id="图片的放大和缩小"><a href="#图片的放大和缩小" class="headerlink" title="图片的放大和缩小"></a>图片的放大和缩小</h2><p>前述说到Android为了能够更好地适配各种屏幕，会依据当前设备的dpi对drawable-[density]目录中的图片进行缩放，那么什么情况下图片被放大，什么情况下图片被缩小呢？</p><p>为了更好的描述，把“符合当前设备dpi的drawable目录”表示为”匹配目录“。比如，设备的dpi为320，这匹配目录为drawable-xhdpi；设备的dpi为150，则匹配目录为drawable-mdpi。图片的放大和缩小遵循以下规律：</p><ul><li>如果图片所在目录为匹配目录，则图片会根据设备dpi做适当的缩放调整。</li><li>如果图片所在目录dpi低于匹配目录，那么该图片被认为是为低密度设备需要的，现在要显示在高密度设备上，图片会被放大。</li><li>如果图片所在目录dpi高于匹配目录，那么该图片被认为是为高密度设备需要的，现在要显示在低密度设备上，图片会被缩小。</li><li>如果图片所在目录为drawable-nodpi，则无论设备dpi为多少，保留原图片大小，不进行缩放。</li></ul><p>那么六种通用密度下的缩放倍数是多少呢？以mdpi为基线，各密度目录下的放大倍数（即缩放因子density）如下</p><table><thead><tr><th style="text-align:center">密度</th><th style="text-align:center">放大倍数</th></tr></thead><tbody><tr><td style="text-align:center">ldpi</td><td style="text-align:center">0.75</td></tr><tr><td style="text-align:center">mdpi</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">hdpi</td><td style="text-align:center">1.5</td></tr><tr><td style="text-align:center">xhdpi</td><td style="text-align:center">2.0</td></tr><tr><td style="text-align:center">xxhdpi</td><td style="text-align:center">3.0</td></tr><tr><td style="text-align:center">xxxhdpi</td><td style="text-align:center">4.0</td></tr></tbody></table><p>例如，当前设备的dpi是480（即xxhdpi），那么对于存放于mdpi目录中的图片会被放大三倍。对于很多设备，其dpi并不刚好是六种通用密度最大dpi，这种情况下，图片的缩放倍数如何计算呢？</p><p>稍微思考一下，我们就可以得到通用的缩放倍数（缩放因子）计算方法：对于任意设备，各drawable-[density]目录下的图片放大倍数的计算公式</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp4npoaguaj317c06sq4a.jpg" alt="缩放因子计算公式" width="100px"><br><br></div><p>那么，图片的实现显示尺寸通过图片尺寸乘以缩放倍数就可以得到了。</p><h2 id="实例验证"><a href="#实例验证" class="headerlink" title="实例验证"></a>实例验证</h2><ul><li><p>验证图片的放大和缩小</p><p>在配置为1080×1920 - 420dpi的模拟器上，从网上找一张Android logo图片分别放在drawable-mdpi、drawable-xxhdpi、drawable-xxxhdpi文件夹下，查看图片的显示效果（如下）。从图中可以明显看到图片的放大和缩小，且比设备屏幕密度低的drawable-mdpi目录图片被放大，比设备屏幕密度高的drawable-xxxhdpi目录图片被缩小。</p><div align="center"><br><br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fp4nrcgrakj30zb0ho75t.jpg" alt="三种不同密度下的图片显示效果" width="100px"><br><br></div></li><li><p>验证缩放倍数</p><p>在Sketch里简单绘制一张图，分别导出一倍图（1x）和三倍图（3x），并假设实际标注为一倍图的尺寸。表示如下</p><div align="center"><br><br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fp4nsbot81j310a0d877a.jpg" alt="标注尺寸及一倍图和三倍图像素" width="100px"><br><br></div><p>在配置为1080×1920 - 420dpi的模拟器上，1倍图和3倍图在wrap_content的情况下，宽高应该符合上表。按照上面对放大倍数的分析，分别把1倍图和3倍图置于drawable-mdpi和drawable-xxhdpi目录下，查看图片宽高。</p><div align="center"><br><br><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fp4ntagwtdj310a0qntc2.jpg" alt="1倍图和3倍图在分别在drawable-mdpi和drawable-xxhdpi目录下的显示效果及宽高" width="100px"><br><br></div><p>该模拟器屏幕dpi横纵方向均为420，drawable-mdpi目录最大dpi值为160，drawable-xxhdpi目录最大dpi值为480。通过上述分析的计算公式，可计算图片预期宽高：</p><ul><li><p>drawable-mdpi</p><p>scale = 420/160</p><p>1x：98 × scale = 98 × 420/160 = 257</p><p>3x：294 × scale = 294 × 420/160 = 772</p></li><li><p>drawable-xxhdpi</p><p>scale = 420/480</p><p>1x：98 × scale = 98 × 420/480 = 86</p><p>3x：294 × scale = 294 × 420/480 = 257</p></li></ul><p>由于像素没有小数，上述计算结果进行了四舍五入。从结果可以看出，公式计算结果和实际显示效果一致。另一方面，在该dpi下，图片放置于drawable-xxhdpi目录下，图片的显示宽高更接近于图片实际大小。</p><p>这部分的验证大家可以自己测试一下，基本规律是没有问题的。</p></li></ul><h1 id="最后定切图"><a href="#最后定切图" class="headerlink" title="最后定切图"></a>最后定切图</h1><p>到此，我们已经知道了Android会按照特定规则对图片进行缩放，以更好地适配各种配置的屏幕。那么在我们关注切图之前，首先考虑一下图片缩放带来的影响。</p><p>嗯，比如容易想到的一点就是会引起内存的变化。当一张图片被放大时，像素增加，必然会引起内存占用量增加；图片被缩小时，像素减少，内存占用量就会降低。内存的使用量可通过Android Monitor来查看。对于上述Android logo那张图片，同样在420dpi的设备上，分别将图片放置于drawable-mdpi和drawable-xxhdpi目录下，内存占用情况如下</p><div align="center"><br><br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fp4nu4u9lvj311w08cmz0.jpg" alt="特定图片在drawable-mdpi和drawable-xxhdpi目录下的内存占用" width="100px"><br><br></div><p>可以看到，仅仅一张图片的内存占用差别就已经在MB级别了。图片放大的内存成本将是不得不考虑的一个重要因素了。</p><hr><p>关于切图的选取，Android官方给的建议，各种密度都给出一套图，分别放置在对应的drawable目录下，这种适配是最好的。但也存在问题，一是这种方式会增大安装包的大小；二是很多公司UI在出图时只会出一套。</p><p>在这种情况下，怎么使用好这一套切图呢？由于目前的Android智能手机的屏幕基本都在1080p了，屏幕的dpi多数都处于320~480，为了更好地适配，同时为了节省内存成本，建议将切图放置在drawable-xxhdpi目录，同时建议UI针对该密度的设备设计切图。如果UI的切图基于不同尺寸设计，Sketch导出切图时须调整相应的倍数。</p><p>例如，假设切图基于376×667的一倍屏幕设计，而要适配1080×1920的屏幕，导出三倍图存放于drawable-xxhdpi目录是适配最好的。</p><p>好了，关于drawable图片适配方面就暂时介绍到这，相信看了后会有一定的认识，在处理平时项目相关问题时，也会有一定的想法了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="external">支持多种屏幕</a></li><li><a href="https://developer.android.com/guide/topics/resources/providing-resources.html#BestMatch" target="_blank" rel="external">Android 如何查找最佳匹配资源</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Android机型众多，屏幕尺寸、分辨率各有不同。对于Android开发人员来说，如何提高APP中图片对各种机型的适配是基本技能之一。借着项目中遇到的图片适配问题，在总结项目时，就想着顺带把这部分好好捋一捋，作为一个记录，也为不是很清楚这部分的人提供一个参考。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://youngmeng.org/categories/Android/"/>
    
    
      <category term="技术" scheme="http://youngmeng.org/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>说说Android中的touch mode</title>
    <link href="http://youngmeng.org/%E8%AF%B4%E8%AF%B4Android%E4%B8%AD%E7%9A%84touch-mode/"/>
    <id>http://youngmeng.org/说说Android中的touch-mode/</id>
    <published>2016-12-14T12:44:20.000Z</published>
    <updated>2018-03-07T16:30:11.203Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间做项目，在解决一个小bug的过程中，碰到一个坑，花费了一大天的时间来填坑，终于排查出了原因：由于某个Edit Text调用了requestFocusFromTouch()方法导致的，将获取焦点的方法换成requestFocus()，则问题不再复现。这就激发了我对这两个方法的好奇，准备看看它们葫芦里到底装的什么。</p><a id="more"></a><h2 id="先从touch-mode说起"><a href="#先从touch-mode说起" class="headerlink" title="先从touch mode说起"></a>先从<em>touch mode</em>说起</h2><p>顾名思义，<em>touch mode</em>就是“触摸模式”。那到底什么是触摸模式呢？从Android官方对<em>touch mode</em>的定义（<a href="https://developer.android.com/reference/android/view/View.html#TouchMode" target="_blank" rel="external">View-Touch Mode</a>)可以知道：</p><blockquote><p>Android系统的交互方式有<em>方向键</em>、<em>滚动球</em>和<em>触摸</em>几种方式。采用方向键、滚动球等方式操作，需要通过焦点和高亮来表示此时操作的view；如果设备具备触摸能力，就可以通过触摸而不需要view高亮，这种触摸的交互方式就是<strong>touch mode</strong>。</p></blockquote><p>由于现在大多数Android智能手机设备都支持触摸能力，以致于很容易让开发人员忽略掉touch mode只是Android交互方式的一种。而这种触摸的交互方式不同于方向键和滚动球：在后者交互方式下，Android必须先让控件获得焦点（比如高亮、边框等），用户才知道目前正在操作的是哪一个控件；前者的交互方式则可以通过手指直接触摸点击需要操作的控件，这个时候自然不需要再高亮显示焦点了。</p><p>那Android设备什么时候处于touch mode呢？</p><blockquote><p>对于具有触摸能力的设备，一旦用户触摸到屏幕，设备就进入了touch mode；用户使用方向键或者滚动球时，设备就会退出touch mode。</p></blockquote><p>touch mode是跨Activitys的（across Activitys），任何时候都可以通过调用isInTouchMode()方法来判断设备当前是否处于touch mode状态。而且，设备一旦进入touch mode状态，就会失去控件的selection状态和focus状态（In touch mode, there is no focus and no selection）。</p><p>看完上面的介绍，不免产生疑问：通过触摸的方式，触摸任何控件是不是都会获得焦点呢？对于某些控件，为什么用户触摸后会获得焦点并可以输入内容呢？</p><p>答案显然是否定的，因为有些控件是不需要获得焦点的，比如Button。Android是考虑这一点的，并提供了API来判断：</p><blockquote><p>只有当view的isFocusableInTouchMode()为true时，view才是可获得焦点的。不同view该值默认不同，例如，Edit Text为true，Button为false。</p></blockquote><p>Focusable可以理解为控件是否具有获得焦点（Focus）的能力，focusable in touch mode是touch mode下焦点存在的一种特殊形式，这种方式在两种情况下会发生：一是Edit Text接收输入的时候，二是List View的过滤打开时。</p><p>在touch mode下，如果isFocusableInTouchMode()为false，用户在触摸屏幕时是无法获取focus的，如果是点击，在ACTION_UP事件到来时，会触发onClickListener；而如果isFocusableInTouchMode()为true，用户通过触摸来点击控件，控件首先会获得focus，如果获取focus成功就不会再触发onClickListener。</p><p>相信到这里，应该对touch mode有一个相对清晰的认识了。那么我们在代码中怎么知道设备是不是处于touch mode状态呢，Android官方在View类中提供了以下方法</p><blockquote><p> boolean isInTouchMode()</p></blockquote><p>来判断设备当前是否处于touch mode。</p><p>通过上面的了解，发现touch mode是Android设备的一种交互方式。在平时的项目开发中，经常需要获得某个控件的焦点，比如，自动获得某个edit text的焦点，以方便用户输入。</p><p>那么，对于大多数智能手机（具有touch mode能力）而言，如何获取view的焦点呢？</p><h2 id="再说requestFocus"><a href="#再说requestFocus" class="headerlink" title="再说requestFocus"></a>再说requestFocus</h2><p>首先要明确一点的是，view要获取焦点，就必须具备获取焦点的能力（focusable）。Android在API中提供了两个方法来更改view是否能够获得焦点</p><blockquote><ol><li><p>void setFocusable(boolean focusable)</p></li><li><p>void setFocusableInTouchMode(boolean focusableInTouchMode)</p></li></ol></blockquote><p>这两个方法通过传入的参数是true或者false来控制view是否具有获得焦点的能力，在xml文件中对应同样的属性定义。要说明的一点是，方法1如果设置为了false，则isFocusable()和isFocusableInTouchMode()均为false。</p><p>例如，对于一个EditText类型的view调用该方法，并传入参数<em>false</em>，此时，再点击屏幕上的edit text，则无法获取焦点。</p><p>因此，在touch mode下，view要获得焦点，首先要设置其是focusable的。当然，特定view默认就是focusable的，比如edit text。</p><p>具备焦点能力后，Android提供了两个方法来获得焦点：</p><ul><li><strong>requestFocus()</strong></li><li><strong>requestFocusFromTouch()</strong></li></ul><p>从方法名就能看出两个方法的区别。其差异在各种博客中都提到的是：requestFocus在几种特殊情况下不能够获得焦点</p><ol><li>调用requestFocus获取焦点的view不支持Focus。比如，button。</li><li>调用requestFocus获取焦点的view支持Focus，但不支持touch mode下的Focus。</li></ol><p>这个比较好理解，就不举例来说明了。值得一提的是，requestFocuFromTouch调用后，该view会从touch mode变成非touch mode。其实，从源码就能看出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestFocusFromTouch</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="comment">// Leave touch mode if we need to</span></div><div class="line">     <span class="keyword">if</span> (isInTouchMode()) &#123;</div><div class="line">         ViewRootImpl viewRoot = getViewRootImpl();</div><div class="line">         <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span>) &#123;</div><div class="line">             viewRoot.ensureTouchMode(<span class="keyword">false</span>);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> requestFocus(View.FOCUS_DOWN);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果需要的话，view会离开touch mode。</p><h2 id="谈谈项目中遇到的问题"><a href="#谈谈项目中遇到的问题" class="headerlink" title="谈谈项目中遇到的问题"></a>谈谈项目中遇到的问题</h2><p>这个时候再来看项目遇到的问题，就很好理解了。</p><p>当时的问题是：点击activity中的一个button弹出一个对话框，对话框中是List View的一个列表，点击任一item，对话框关闭，并让activity中的一个Text View获得输入焦点。由于团队其他人员获取焦点使用的是requestFocusFromTouch，导致每次点击选择item后，List View都会从touch mode转变为非touch mode状态，那么如果这时再显示对话框，List View就会处于selection状态，默认选中第一个item。而这种状态是我们不想要的。</p><div align="center"><br><br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fp4njgw0t6j30oo0iujs0.jpg" alt="List View默认将第一个item设为selection" width="100px"><br><br></div><p>知道了问题所在，解决方法也就很容易了，只需要把requestFocusFromTouch替换为requestFrocus即可，这样保证List View始终都是touch mode状态。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.android.com/reference/android/view/View.html#TouchMode" target="_blank" rel="external">https://developer.android.com/reference/android/view/View.html#TouchMode</a></li><li><a href="https://android-developers.googleblog.com/2008/12/touch-mode.html" target="_blank" rel="external">https://android-developers.googleblog.com/2008/12/touch-mode.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间做项目，在解决一个小bug的过程中，碰到一个坑，花费了一大天的时间来填坑，终于排查出了原因：由于某个Edit Text调用了requestFocusFromTouch()方法导致的，将获取焦点的方法换成requestFocus()，则问题不再复现。这就激发了我对这两个方法的好奇，准备看看它们葫芦里到底装的什么。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://youngmeng.org/categories/Android/"/>
    
    
      <category term="技术" scheme="http://youngmeng.org/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>建站啦</title>
    <link href="http://youngmeng.org/%E5%BB%BA%E7%AB%99/"/>
    <id>http://youngmeng.org/建站/</id>
    <published>2016-12-01T12:13:14.000Z</published>
    <updated>2018-03-07T15:04:24.386Z</updated>
    
    <content type="html"><![CDATA[<p>写在建站之时<br><a id="more"></a></p><h1 id="写在建站之时"><a href="#写在建站之时" class="headerlink" title="写在建站之时"></a>写在建站之时</h1><ul><li><p>目的</p><p>工作之后，碰到了很多问题，看了很多网络上的各种博客，学到了大牛们的知识之外，也佩服他们对知识的共享。于是，便萌发了自己建立博客的想法：</p><ul><li>工作进步较慢，以博客的方式记录自己的学习成长，希望加快自己的进步。</li><li>学习了很多网络前辈们的经验，也希望自己能够为开源知识贡献一点力量，也算是对开源博客的一种回馈。</li><li>以我这么有个性的人，必然搞一个自己的个性域名。</li></ul></li><li><p>博文</p><p>主要以原创为主，用自己的方式记录自己项目、学习过程中的一些问题，希望简单、易理解，为后来学习者提供一些帮助。</p><p>偶尔可能会记录自己的一些想法、看法，仅作为自己的一种记录。</p></li><li><p>版权</p><p>作者会坚持原创精神，如果你觉得博文不错，欢迎转载、交流，但请必须在明确位置标明文章来源。</p></li></ul><p>2016年12月01日</p><p>youngmeng</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在建站之时&lt;br&gt;
    
    </summary>
    
      <category term="young" scheme="http://youngmeng.org/categories/young/"/>
    
    
      <category term="其他" scheme="http://youngmeng.org/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
